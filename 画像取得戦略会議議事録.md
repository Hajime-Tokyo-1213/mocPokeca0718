# 画像取得戦略会議議事録

## 会議日時
2025年8月5日

## 参加者
- **Dr. Alex Chen** - セキュリティエンジニア（MIT博士）
- **Prof. Maria Rodriguez** - 分散システムアーキテクト（スタンフォード大学教授）
- **Eng. Takeshi Yamamoto** - フルスタックエンジニア（元Google）
- **Dr. Sarah Williams** - 機械学習エンジニア（データ抽出専門家）

## 議題
Googleスプレッドシートからの画像取得方法を、getdata.txtに記載されたネットワーク監視アプローチへ変更し、画像をpublic/imagesディレクトリに保存する実装について

## 現状分析

### 現在の実装（HTMLParseStrategy）
- **手法**: GoogleスプレッドシートのHTMLをパースして画像URLを抽出
- **問題点**: 
  - スプレッドシートの構造変更に脆弱
  - 動的コンテンツの取得が困難
  - レート制限への対応が限定的

### getdata.txtのアプローチ
- **手法**: ネットワークリクエストを監視し、`lh3.googleusercontent.com`からの画像を直接取得
- **利点**:
  - より確実な画像URL取得
  - 高解像度画像への直接アクセス
  - スプレッドシートの構造に依存しない

## 技術的議論

### Dr. Alex Chen（セキュリティ観点）
「ネットワーク監視アプローチは興味深いが、実装には注意が必要。Node.jsでのネットワーク監視は、Puppeteerのような自動化ツールを使用することになる。セキュリティ的には以下の考慮が必要：
1. ヘッドレスブラウザのサンドボックス化
2. 取得した画像の検証（サイズ、形式、内容）
3. CORS制約の適切な処理」

### Prof. Maria Rodriguez（アーキテクチャ観点）
「システム設計の観点から、以下の戦略を提案：
1. **NetworkMonitorStrategy**クラスの新規作成
2. 既存の戦略パターンへの統合
3. 画像の永続化レイヤーの追加
4. キャッシュ機構の実装で負荷軽減」

### Eng. Takeshi Yamamoto（実装観点）
「実装面では、以下のアプローチが現実的：
```typescript
// NetworkMonitorStrategy の実装例
class NetworkMonitorStrategy implements ImageFetchStrategy {
  async fetch(): Promise<ImageData[]> {
    // 1. Puppeteerでページを開く
    // 2. ネットワークイベントを監視
    // 3. lh3.googleusercontent.comからの画像を収集
    // 4. 画像をダウンロードしてpublic/imagesに保存
    // 5. ローカルパスでImageDataを返す
  }
}
```
画像の保存は非同期で行い、プログレッシブエンハンスメントを実現」

### Dr. Sarah Williams（データ抽出観点）
「機械学習の観点から、以下の最適化を提案：
1. 画像URLパターンの学習による効率的な抽出
2. 重複画像の検出と除外
3. 画像メタデータの自動抽出
4. バッチ処理による効率化」

## 合意事項と実装方針

### 1. 新戦略クラスの実装
```typescript
export class NetworkMonitorStrategy implements ImageFetchStrategy {
  name = 'Network Monitor';
  private imageDir = 'public/images';
  
  async fetch(): Promise<ImageData[]> {
    // Puppeteerを使用した実装
    const browser = await puppeteer.launch({ headless: true });
    const page = await browser.newPage();
    
    const imageUrls: string[] = [];
    
    // ネットワークリクエストの監視
    page.on('response', async (response) => {
      const url = response.url();
      if (url.includes('lh3.googleusercontent.com')) {
        imageUrls.push(url);
      }
    });
    
    // スプレッドシートにアクセス
    await page.goto(spreadsheetUrl);
    await page.waitForTimeout(5000);
    
    // 画像のダウンロードと保存
    const imageData = await this.downloadAndSaveImages(imageUrls);
    
    await browser.close();
    return imageData;
  }
}
```

### 2. 画像保存機能の実装
```typescript
private async downloadAndSaveImages(urls: string[]): Promise<ImageData[]> {
  const imageData: ImageData[] = [];
  
  for (const url of urls) {
    try {
      // 高解像度URLへの変換
      const hdUrl = this.removeResizeParams(url);
      
      // 画像のダウンロード
      const response = await axios.get(hdUrl, { responseType: 'arraybuffer' });
      
      // ファイル名の生成
      const filename = this.generateFileName(url);
      const localPath = path.join(this.imageDir, filename);
      
      // ファイルの保存
      await fs.writeFile(localPath, response.data);
      
      // ImageDataの作成
      imageData.push({
        title: this.extractTitleFromUrl(url),
        imageUrl: `/images/${filename}`,
        characterName: '',
        modelNumber: ''
      });
    } catch (error) {
      console.error(`Failed to download image: ${url}`, error);
    }
  }
  
  return imageData;
}
```

### 3. 段階的移行計画
1. **Phase 1**: NetworkMonitorStrategyの基本実装
2. **Phase 2**: 画像ダウンロード・保存機能の実装
3. **Phase 3**: 既存戦略との統合とフォールバック設定
4. **Phase 4**: パフォーマンス最適化とキャッシング

### 4. 技術的要件
- **依存関係**: puppeteer, axios, fs-extra
- **ディレクトリ構造**: 
  ```
  public/
  └── images/
      ├── cards/
      │   ├── ar/
      │   ├── sr/
      │   ├── sar/
      │   └── ur/
      └── .gitkeep
  ```
- **環境変数**: 
  - `NEXT_PUBLIC_USE_NETWORK_MONITOR`: ネットワーク監視戦略の有効化
  - `NEXT_PUBLIC_IMAGE_CACHE_DURATION`: 画像キャッシュ期間

## リスクと対策

### リスク
1. **パフォーマンス**: Puppeteerの起動オーバーヘッド
2. **ストレージ**: 大量の画像ファイルによる容量圧迫
3. **レート制限**: Googleからのアクセス制限
4. **メンテナンス**: 画像ファイルの同期管理

### 対策
1. **バックグラウンドジョブ**: 定期的な画像更新処理
2. **画像最適化**: WebP形式への変換、圧縮
3. **キャッシング**: CloudflareやVercelのCDN活用
4. **モニタリング**: 画像取得の成功率追跡

## 結論

getdata.txtのアプローチは技術的に実現可能であり、より堅牢な画像取得システムを構築できる。ただし、実装には慎重な設計と段階的な移行が必要。NetworkMonitorStrategyを新たに実装し、既存の戦略パターンに統合することで、柔軟で拡張可能なシステムを実現する。

## アクションアイテム
1. [ ] Puppeteerの依存関係追加とセットアップ
2. [ ] NetworkMonitorStrategyクラスの実装
3. [ ] 画像保存用ディレクトリ構造の作成
4. [ ] 画像ダウンロード・保存機能の実装
5. [ ] 既存のImageDataFetcherへの統合
6. [ ] テストとパフォーマンス検証
7. [ ] ドキュメントの更新